"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mdast-util-gfm-table";
exports.ids = ["vendor-chunks/mdast-util-gfm-table"];
exports.modules = {

/***/ "(rsc)/./node_modules/mdast-util-gfm-table/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/mdast-util-gfm-table/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   gfmTableFromMarkdown: () => (/* binding */ gfmTableFromMarkdown),\n/* harmony export */   gfmTableToMarkdown: () => (/* binding */ gfmTableToMarkdown)\n/* harmony export */ });\n/* harmony import */ var devlop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! devlop */ \"(rsc)/./node_modules/devlop/lib/development.js\");\n/* harmony import */ var markdown_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! markdown-table */ \"(rsc)/./node_modules/markdown-table/index.js\");\n/* harmony import */ var mdast_util_to_markdown__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mdast-util-to-markdown */ \"(rsc)/./node_modules/mdast-util-to-markdown/lib/handle/index.js\");\n/**\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('mdast').Table} Table\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('mdast').TableRow} TableRow\n *\n * @typedef {import('markdown-table').Options} MarkdownTableOptions\n *\n * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n *\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').State} State\n * @typedef {import('mdast-util-to-markdown').Info} Info\n */ /**\n * @typedef Options\n *   Configuration.\n * @property {boolean | null | undefined} [tableCellPadding=true]\n *   Whether to add a space of padding between delimiters and cells (default:\n *   `true`).\n * @property {boolean | null | undefined} [tablePipeAlign=true]\n *   Whether to align the delimiters (default: `true`).\n * @property {MarkdownTableOptions['stringLength'] | null | undefined} [stringLength]\n *   Function to detect the length of table cell content, used when aligning\n *   the delimiters between cells (optional).\n */ \n\n\n/**\n * Create an extension for `mdast-util-from-markdown` to enable GFM tables in\n * markdown.\n *\n * @returns {FromMarkdownExtension}\n *   Extension for `mdast-util-from-markdown` to enable GFM tables.\n */ function gfmTableFromMarkdown() {\n    return {\n        enter: {\n            table: enterTable,\n            tableData: enterCell,\n            tableHeader: enterCell,\n            tableRow: enterRow\n        },\n        exit: {\n            codeText: exitCodeText,\n            table: exitTable,\n            tableData: exit,\n            tableHeader: exit,\n            tableRow: exit\n        }\n    };\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */ function enterTable(token) {\n    const align = token._align;\n    (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(align, \"expected `_align` on table\");\n    this.enter({\n        type: \"table\",\n        align: align.map(function(d) {\n            return d === \"none\" ? null : d;\n        }),\n        children: []\n    }, token);\n    this.data.inTable = true;\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */ function exitTable(token) {\n    this.exit(token);\n    this.data.inTable = undefined;\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */ function enterRow(token) {\n    this.enter({\n        type: \"tableRow\",\n        children: []\n    }, token);\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */ function exit(token) {\n    this.exit(token);\n}\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */ function enterCell(token) {\n    this.enter({\n        type: \"tableCell\",\n        children: []\n    }, token);\n}\n// Overwrite the default code text data handler to unescape escaped pipes when\n// they are in tables.\n/**\n * @this {CompileContext}\n * @type {FromMarkdownHandle}\n */ function exitCodeText(token) {\n    let value = this.resume();\n    if (this.data.inTable) {\n        value = value.replace(/\\\\([\\\\|])/g, replace);\n    }\n    const node = this.stack[this.stack.length - 1];\n    (0,devlop__WEBPACK_IMPORTED_MODULE_0__.ok)(node.type === \"inlineCode\");\n    node.value = value;\n    this.exit(token);\n}\n/**\n * @param {string} $0\n * @param {string} $1\n * @returns {string}\n */ function replace($0, $1) {\n    // Pipes work, backslashes don’t (but can’t escape pipes).\n    return $1 === \"|\" ? $1 : $0;\n}\n/**\n * Create an extension for `mdast-util-to-markdown` to enable GFM tables in\n * markdown.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration.\n * @returns {ToMarkdownExtension}\n *   Extension for `mdast-util-to-markdown` to enable GFM tables.\n */ function gfmTableToMarkdown(options) {\n    const settings = options || {};\n    const padding = settings.tableCellPadding;\n    const alignDelimiters = settings.tablePipeAlign;\n    const stringLength = settings.stringLength;\n    const around = padding ? \" \" : \"|\";\n    return {\n        unsafe: [\n            {\n                character: \"\\r\",\n                inConstruct: \"tableCell\"\n            },\n            {\n                character: \"\\n\",\n                inConstruct: \"tableCell\"\n            },\n            // A pipe, when followed by a tab or space (padding), or a dash or colon\n            // (unpadded delimiter row), could result in a table.\n            {\n                atBreak: true,\n                character: \"|\",\n                after: \"[\t :-]\"\n            },\n            // A pipe in a cell must be encoded.\n            {\n                character: \"|\",\n                inConstruct: \"tableCell\"\n            },\n            // A colon must be followed by a dash, in which case it could start a\n            // delimiter row.\n            {\n                atBreak: true,\n                character: \":\",\n                after: \"-\"\n            },\n            // A delimiter row can also start with a dash, when followed by more\n            // dashes, a colon, or a pipe.\n            // This is a stricter version than the built in check for lists, thematic\n            // breaks, and setex heading underlines though:\n            // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n            {\n                atBreak: true,\n                character: \"-\",\n                after: \"[:|-]\"\n            }\n        ],\n        handlers: {\n            inlineCode: inlineCodeWithTable,\n            table: handleTable,\n            tableCell: handleTableCell,\n            tableRow: handleTableRow\n        }\n    };\n    /**\n   * @type {ToMarkdownHandle}\n   * @param {Table} node\n   */ function handleTable(node, _, state, info) {\n        return serializeData(handleTableAsData(node, state, info), node.align);\n    }\n    /**\n   * This function isn’t really used normally, because we handle rows at the\n   * table level.\n   * But, if someone passes in a table row, this ensures we make somewhat sense.\n   *\n   * @type {ToMarkdownHandle}\n   * @param {TableRow} node\n   */ function handleTableRow(node, _, state, info) {\n        const row = handleTableRowAsData(node, state, info);\n        const value = serializeData([\n            row\n        ]);\n        // `markdown-table` will always add an align row\n        return value.slice(0, value.indexOf(\"\\n\"));\n    }\n    /**\n   * @type {ToMarkdownHandle}\n   * @param {TableCell} node\n   */ function handleTableCell(node, _, state, info) {\n        const exit = state.enter(\"tableCell\");\n        const subexit = state.enter(\"phrasing\");\n        const value = state.containerPhrasing(node, {\n            ...info,\n            before: around,\n            after: around\n        });\n        subexit();\n        exit();\n        return value;\n    }\n    /**\n   * @param {Array<Array<string>>} matrix\n   * @param {Array<string | null | undefined> | null | undefined} [align]\n   */ function serializeData(matrix, align) {\n        return (0,markdown_table__WEBPACK_IMPORTED_MODULE_1__.markdownTable)(matrix, {\n            align,\n            // @ts-expect-error: `markdown-table` types should support `null`.\n            alignDelimiters,\n            // @ts-expect-error: `markdown-table` types should support `null`.\n            padding,\n            // @ts-expect-error: `markdown-table` types should support `null`.\n            stringLength\n        });\n    }\n    /**\n   * @param {Table} node\n   * @param {State} state\n   * @param {Info} info\n   */ function handleTableAsData(node, state, info) {\n        const children = node.children;\n        let index = -1;\n        /** @type {Array<Array<string>>} */ const result = [];\n        const subexit = state.enter(\"table\");\n        while(++index < children.length){\n            result[index] = handleTableRowAsData(children[index], state, info);\n        }\n        subexit();\n        return result;\n    }\n    /**\n   * @param {TableRow} node\n   * @param {State} state\n   * @param {Info} info\n   */ function handleTableRowAsData(node, state, info) {\n        const children = node.children;\n        let index = -1;\n        /** @type {Array<string>} */ const result = [];\n        const subexit = state.enter(\"tableRow\");\n        while(++index < children.length){\n            // Note: the positional info as used here is incorrect.\n            // Making it correct would be impossible due to aligning cells?\n            // And it would need copy/pasting `markdown-table` into this project.\n            result[index] = handleTableCell(children[index], node, state, info);\n        }\n        subexit();\n        return result;\n    }\n    /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineCode} node\n   */ function inlineCodeWithTable(node, parent, state) {\n        let value = mdast_util_to_markdown__WEBPACK_IMPORTED_MODULE_2__.handle.inlineCode(node, parent, state);\n        if (state.stack.includes(\"tableCell\")) {\n            value = value.replace(/\\|/g, \"\\\\$&\");\n        }\n        return value;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWRhc3QtdXRpbC1nZm0tdGFibGUvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FFRDs7Ozs7Ozs7Ozs7Q0FXQyxHQUVrQztBQUNTO0FBQ1U7QUFFdEQ7Ozs7OztDQU1DLEdBQ00sU0FBU0k7SUFDZCxPQUFPO1FBQ0xDLE9BQU87WUFDTEMsT0FBT0M7WUFDUEMsV0FBV0M7WUFDWEMsYUFBYUQ7WUFDYkUsVUFBVUM7UUFDWjtRQUNBQyxNQUFNO1lBQ0pDLFVBQVVDO1lBQ1ZULE9BQU9VO1lBQ1BSLFdBQVdLO1lBQ1hILGFBQWFHO1lBQ2JGLFVBQVVFO1FBQ1o7SUFDRjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU04sV0FBV1UsS0FBSztJQUN2QixNQUFNQyxRQUFRRCxNQUFNRSxNQUFNO0lBQzFCbEIsMENBQU1BLENBQUNpQixPQUFPO0lBQ2QsSUFBSSxDQUFDYixLQUFLLENBQ1I7UUFDRWUsTUFBTTtRQUNORixPQUFPQSxNQUFNRyxHQUFHLENBQUMsU0FBVUMsQ0FBQztZQUMxQixPQUFPQSxNQUFNLFNBQVMsT0FBT0E7UUFDL0I7UUFDQUMsVUFBVSxFQUFFO0lBQ2QsR0FDQU47SUFFRixJQUFJLENBQUNPLElBQUksQ0FBQ0MsT0FBTyxHQUFHO0FBQ3RCO0FBRUE7OztDQUdDLEdBQ0QsU0FBU1QsVUFBVUMsS0FBSztJQUN0QixJQUFJLENBQUNKLElBQUksQ0FBQ0k7SUFDVixJQUFJLENBQUNPLElBQUksQ0FBQ0MsT0FBTyxHQUFHQztBQUN0QjtBQUVBOzs7Q0FHQyxHQUNELFNBQVNkLFNBQVNLLEtBQUs7SUFDckIsSUFBSSxDQUFDWixLQUFLLENBQUM7UUFBQ2UsTUFBTTtRQUFZRyxVQUFVLEVBQUU7SUFBQSxHQUFHTjtBQUMvQztBQUVBOzs7Q0FHQyxHQUNELFNBQVNKLEtBQUtJLEtBQUs7SUFDakIsSUFBSSxDQUFDSixJQUFJLENBQUNJO0FBQ1o7QUFFQTs7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LElBQUksRUFBRXlDLE1BQU0sRUFBRWQsS0FBSztRQUM5QyxJQUFJOUIsUUFBUXhCLDBEQUFlQSxDQUFDK0MsVUFBVSxDQUFDcEIsTUFBTXlDLFFBQVFkO1FBRXJELElBQUlBLE1BQU0xQixLQUFLLENBQUN5QyxRQUFRLENBQUMsY0FBYztZQUNyQzdDLFFBQVFBLE1BQU1FLE9BQU8sQ0FBQyxPQUFPO1FBQy9CO1FBRUEsT0FBT0Y7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8va2luZXRpYy13ZWJzaXRlLy4vbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtZ2ZtLXRhYmxlL2xpYi9pbmRleC5qcz82N2JlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5JbmxpbmVDb2RlfSBJbmxpbmVDb2RlXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdCcpLlRhYmxlfSBUYWJsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UYWJsZUNlbGx9IFRhYmxlQ2VsbFxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QnKS5UYWJsZVJvd30gVGFibGVSb3dcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtYXJrZG93bi10YWJsZScpLk9wdGlvbnN9IE1hcmtkb3duVGFibGVPcHRpb25zXG4gKlxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuQ29tcGlsZUNvbnRleHR9IENvbXBpbGVDb250ZXh0XG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLWZyb20tbWFya2Rvd24nKS5FeHRlbnNpb259IEZyb21NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC1mcm9tLW1hcmtkb3duJykuSGFuZGxlfSBGcm9tTWFya2Rvd25IYW5kbGVcbiAqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCdtZGFzdC11dGlsLXRvLW1hcmtkb3duJykuT3B0aW9uc30gVG9NYXJrZG93bkV4dGVuc2lvblxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkhhbmRsZX0gVG9NYXJrZG93bkhhbmRsZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLlN0YXRlfSBTdGF0ZVxuICogQHR5cGVkZWYge2ltcG9ydCgnbWRhc3QtdXRpbC10by1tYXJrZG93bicpLkluZm99IEluZm9cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIE9wdGlvbnNcbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFt0YWJsZUNlbGxQYWRkaW5nPXRydWVdXG4gKiAgIFdoZXRoZXIgdG8gYWRkIGEgc3BhY2Ugb2YgcGFkZGluZyBiZXR3ZWVuIGRlbGltaXRlcnMgYW5kIGNlbGxzIChkZWZhdWx0OlxuICogICBgdHJ1ZWApLlxuICogQHByb3BlcnR5IHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3RhYmxlUGlwZUFsaWduPXRydWVdXG4gKiAgIFdoZXRoZXIgdG8gYWxpZ24gdGhlIGRlbGltaXRlcnMgKGRlZmF1bHQ6IGB0cnVlYCkuXG4gKiBAcHJvcGVydHkge01hcmtkb3duVGFibGVPcHRpb25zWydzdHJpbmdMZW5ndGgnXSB8IG51bGwgfCB1bmRlZmluZWR9IFtzdHJpbmdMZW5ndGhdXG4gKiAgIEZ1bmN0aW9uIHRvIGRldGVjdCB0aGUgbGVuZ3RoIG9mIHRhYmxlIGNlbGwgY29udGVudCwgdXNlZCB3aGVuIGFsaWduaW5nXG4gKiAgIHRoZSBkZWxpbWl0ZXJzIGJldHdlZW4gY2VsbHMgKG9wdGlvbmFsKS5cbiAqL1xuXG5pbXBvcnQge29rIGFzIGFzc2VydH0gZnJvbSAnZGV2bG9wJ1xuaW1wb3J0IHttYXJrZG93blRhYmxlfSBmcm9tICdtYXJrZG93bi10YWJsZSdcbmltcG9ydCB7ZGVmYXVsdEhhbmRsZXJzfSBmcm9tICdtZGFzdC11dGlsLXRvLW1hcmtkb3duJ1xuXG4vKipcbiAqIENyZWF0ZSBhbiBleHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLWZyb20tbWFya2Rvd25gIHRvIGVuYWJsZSBHRk0gdGFibGVzIGluXG4gKiBtYXJrZG93bi5cbiAqXG4gKiBAcmV0dXJucyB7RnJvbU1hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLWZyb20tbWFya2Rvd25gIHRvIGVuYWJsZSBHRk0gdGFibGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2ZtVGFibGVGcm9tTWFya2Rvd24oKSB7XG4gIHJldHVybiB7XG4gICAgZW50ZXI6IHtcbiAgICAgIHRhYmxlOiBlbnRlclRhYmxlLFxuICAgICAgdGFibGVEYXRhOiBlbnRlckNlbGwsXG4gICAgICB0YWJsZUhlYWRlcjogZW50ZXJDZWxsLFxuICAgICAgdGFibGVSb3c6IGVudGVyUm93XG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBjb2RlVGV4dDogZXhpdENvZGVUZXh0LFxuICAgICAgdGFibGU6IGV4aXRUYWJsZSxcbiAgICAgIHRhYmxlRGF0YTogZXhpdCxcbiAgICAgIHRhYmxlSGVhZGVyOiBleGl0LFxuICAgICAgdGFibGVSb3c6IGV4aXRcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdGhpcyB7Q29tcGlsZUNvbnRleHR9XG4gKiBAdHlwZSB7RnJvbU1hcmtkb3duSGFuZGxlfVxuICovXG5mdW5jdGlvbiBlbnRlclRhYmxlKHRva2VuKSB7XG4gIGNvbnN0IGFsaWduID0gdG9rZW4uX2FsaWduXG4gIGFzc2VydChhbGlnbiwgJ2V4cGVjdGVkIGBfYWxpZ25gIG9uIHRhYmxlJylcbiAgdGhpcy5lbnRlcihcbiAgICB7XG4gICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgYWxpZ246IGFsaWduLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZCA9PT0gJ25vbmUnID8gbnVsbCA6IGRcbiAgICAgIH0pLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSxcbiAgICB0b2tlblxuICApXG4gIHRoaXMuZGF0YS5pblRhYmxlID0gdHJ1ZVxufVxuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGV4aXRUYWJsZSh0b2tlbikge1xuICB0aGlzLmV4aXQodG9rZW4pXG4gIHRoaXMuZGF0YS5pblRhYmxlID0gdW5kZWZpbmVkXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZW50ZXJSb3codG9rZW4pIHtcbiAgdGhpcy5lbnRlcih7dHlwZTogJ3RhYmxlUm93JywgY2hpbGRyZW46IFtdfSwgdG9rZW4pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZXhpdCh0b2tlbikge1xuICB0aGlzLmV4aXQodG9rZW4pXG59XG5cbi8qKlxuICogQHRoaXMge0NvbXBpbGVDb250ZXh0fVxuICogQHR5cGUge0Zyb21NYXJrZG93bkhhbmRsZX1cbiAqL1xuZnVuY3Rpb24gZW50ZXJDZWxsKHRva2VuKSB7XG4gIHRoaXMuZW50ZXIoe3R5cGU6ICd0YWJsZUNlbGwnLCBjaGlsZHJlbjogW119LCB0b2tlbilcbn1cblxuLy8gT3ZlcndyaXRlIHRoZSBkZWZhdWx0IGNvZGUgdGV4dCBkYXRhIGhhbmRsZXIgdG8gdW5lc2NhcGUgZXNjYXBlZCBwaXBlcyB3aGVuXG4vLyB0aGV5IGFyZSBpbiB0YWJsZXMuXG4vKipcbiAqIEB0aGlzIHtDb21waWxlQ29udGV4dH1cbiAqIEB0eXBlIHtGcm9tTWFya2Rvd25IYW5kbGV9XG4gKi9cbmZ1bmN0aW9uIGV4aXRDb2RlVGV4dCh0b2tlbikge1xuICBsZXQgdmFsdWUgPSB0aGlzLnJlc3VtZSgpXG5cbiAgaWYgKHRoaXMuZGF0YS5pblRhYmxlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcKFtcXFxcfF0pL2csIHJlcGxhY2UpXG4gIH1cblxuICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdXG4gIGFzc2VydChub2RlLnR5cGUgPT09ICdpbmxpbmVDb2RlJylcbiAgbm9kZS52YWx1ZSA9IHZhbHVlXG4gIHRoaXMuZXhpdCh0b2tlbilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gJDBcbiAqIEBwYXJhbSB7c3RyaW5nfSAkMVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZSgkMCwgJDEpIHtcbiAgLy8gUGlwZXMgd29yaywgYmFja3NsYXNoZXMgZG9u4oCZdCAoYnV0IGNhbuKAmXQgZXNjYXBlIHBpcGVzKS5cbiAgcmV0dXJuICQxID09PSAnfCcgPyAkMSA6ICQwXG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBmb3IgYG1kYXN0LXV0aWwtdG8tbWFya2Rvd25gIHRvIGVuYWJsZSBHRk0gdGFibGVzIGluXG4gKiBtYXJrZG93bi5cbiAqXG4gKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAqICAgQ29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIHtUb01hcmtkb3duRXh0ZW5zaW9ufVxuICogICBFeHRlbnNpb24gZm9yIGBtZGFzdC11dGlsLXRvLW1hcmtkb3duYCB0byBlbmFibGUgR0ZNIHRhYmxlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdmbVRhYmxlVG9NYXJrZG93bihvcHRpb25zKSB7XG4gIGNvbnN0IHNldHRpbmdzID0gb3B0aW9ucyB8fCB7fVxuICBjb25zdCBwYWRkaW5nID0gc2V0dGluZ3MudGFibGVDZWxsUGFkZGluZ1xuICBjb25zdCBhbGlnbkRlbGltaXRlcnMgPSBzZXR0aW5ncy50YWJsZVBpcGVBbGlnblxuICBjb25zdCBzdHJpbmdMZW5ndGggPSBzZXR0aW5ncy5zdHJpbmdMZW5ndGhcbiAgY29uc3QgYXJvdW5kID0gcGFkZGluZyA/ICcgJyA6ICd8J1xuXG4gIHJldHVybiB7XG4gICAgdW5zYWZlOiBbXG4gICAgICB7Y2hhcmFjdGVyOiAnXFxyJywgaW5Db25zdHJ1Y3Q6ICd0YWJsZUNlbGwnfSxcbiAgICAgIHtjaGFyYWN0ZXI6ICdcXG4nLCBpbkNvbnN0cnVjdDogJ3RhYmxlQ2VsbCd9LFxuICAgICAgLy8gQSBwaXBlLCB3aGVuIGZvbGxvd2VkIGJ5IGEgdGFiIG9yIHNwYWNlIChwYWRkaW5nKSwgb3IgYSBkYXNoIG9yIGNvbG9uXG4gICAgICAvLyAodW5wYWRkZWQgZGVsaW1pdGVyIHJvdyksIGNvdWxkIHJlc3VsdCBpbiBhIHRhYmxlLlxuICAgICAge2F0QnJlYWs6IHRydWUsIGNoYXJhY3RlcjogJ3wnLCBhZnRlcjogJ1tcXHQgOi1dJ30sXG4gICAgICAvLyBBIHBpcGUgaW4gYSBjZWxsIG11c3QgYmUgZW5jb2RlZC5cbiAgICAgIHtjaGFyYWN0ZXI6ICd8JywgaW5Db25zdHJ1Y3Q6ICd0YWJsZUNlbGwnfSxcbiAgICAgIC8vIEEgY29sb24gbXVzdCBiZSBmb2xsb3dlZCBieSBhIGRhc2gsIGluIHdoaWNoIGNhc2UgaXQgY291bGQgc3RhcnQgYVxuICAgICAgLy8gZGVsaW1pdGVyIHJvdy5cbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICc6JywgYWZ0ZXI6ICctJ30sXG4gICAgICAvLyBBIGRlbGltaXRlciByb3cgY2FuIGFsc28gc3RhcnQgd2l0aCBhIGRhc2gsIHdoZW4gZm9sbG93ZWQgYnkgbW9yZVxuICAgICAgLy8gZGFzaGVzLCBhIGNvbG9uLCBvciBhIHBpcGUuXG4gICAgICAvLyBUaGlzIGlzIGEgc3RyaWN0ZXIgdmVyc2lvbiB0aGFuIHRoZSBidWlsdCBpbiBjaGVjayBmb3IgbGlzdHMsIHRoZW1hdGljXG4gICAgICAvLyBicmVha3MsIGFuZCBzZXRleCBoZWFkaW5nIHVuZGVybGluZXMgdGhvdWdoOlxuICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9zeW50YXgtdHJlZS9tZGFzdC11dGlsLXRvLW1hcmtkb3duL2Jsb2IvNTFhMjAzOC9saWIvdW5zYWZlLmpzI0w1Nz5cbiAgICAgIHthdEJyZWFrOiB0cnVlLCBjaGFyYWN0ZXI6ICctJywgYWZ0ZXI6ICdbOnwtXSd9XG4gICAgXSxcbiAgICBoYW5kbGVyczoge1xuICAgICAgaW5saW5lQ29kZTogaW5saW5lQ29kZVdpdGhUYWJsZSxcbiAgICAgIHRhYmxlOiBoYW5kbGVUYWJsZSxcbiAgICAgIHRhYmxlQ2VsbDogaGFuZGxlVGFibGVDZWxsLFxuICAgICAgdGFibGVSb3c6IGhhbmRsZVRhYmxlUm93XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtUb01hcmtkb3duSGFuZGxlfVxuICAgKiBAcGFyYW0ge1RhYmxlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZShub2RlLCBfLCBzdGF0ZSwgaW5mbykge1xuICAgIHJldHVybiBzZXJpYWxpemVEYXRhKGhhbmRsZVRhYmxlQXNEYXRhKG5vZGUsIHN0YXRlLCBpbmZvKSwgbm9kZS5hbGlnbilcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzbuKAmXQgcmVhbGx5IHVzZWQgbm9ybWFsbHksIGJlY2F1c2Ugd2UgaGFuZGxlIHJvd3MgYXQgdGhlXG4gICAqIHRhYmxlIGxldmVsLlxuICAgKiBCdXQsIGlmIHNvbWVvbmUgcGFzc2VzIGluIGEgdGFibGUgcm93LCB0aGlzIGVuc3VyZXMgd2UgbWFrZSBzb21ld2hhdCBzZW5zZS5cbiAgICpcbiAgICogQHR5cGUge1RvTWFya2Rvd25IYW5kbGV9XG4gICAqIEBwYXJhbSB7VGFibGVSb3d9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVRhYmxlUm93KG5vZGUsIF8sIHN0YXRlLCBpbmZvKSB7XG4gICAgY29uc3Qgcm93ID0gaGFuZGxlVGFibGVSb3dBc0RhdGEobm9kZSwgc3RhdGUsIGluZm8pXG4gICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemVEYXRhKFtyb3ddKVxuICAgIC8vIGBtYXJrZG93bi10YWJsZWAgd2lsbCBhbHdheXMgYWRkIGFuIGFsaWduIHJvd1xuICAgIHJldHVybiB2YWx1ZS5zbGljZSgwLCB2YWx1ZS5pbmRleE9mKCdcXG4nKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtUYWJsZUNlbGx9IG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZVRhYmxlQ2VsbChub2RlLCBfLCBzdGF0ZSwgaW5mbykge1xuICAgIGNvbnN0IGV4aXQgPSBzdGF0ZS5lbnRlcigndGFibGVDZWxsJylcbiAgICBjb25zdCBzdWJleGl0ID0gc3RhdGUuZW50ZXIoJ3BocmFzaW5nJylcbiAgICBjb25zdCB2YWx1ZSA9IHN0YXRlLmNvbnRhaW5lclBocmFzaW5nKG5vZGUsIHtcbiAgICAgIC4uLmluZm8sXG4gICAgICBiZWZvcmU6IGFyb3VuZCxcbiAgICAgIGFmdGVyOiBhcm91bmRcbiAgICB9KVxuICAgIHN1YmV4aXQoKVxuICAgIGV4aXQoKVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8c3RyaW5nPj59IG1hdHJpeFxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ+IHwgbnVsbCB8IHVuZGVmaW5lZH0gW2FsaWduXVxuICAgKi9cbiAgZnVuY3Rpb24gc2VyaWFsaXplRGF0YShtYXRyaXgsIGFsaWduKSB7XG4gICAgcmV0dXJuIG1hcmtkb3duVGFibGUobWF0cml4LCB7XG4gICAgICBhbGlnbixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGBtYXJrZG93bi10YWJsZWAgdHlwZXMgc2hvdWxkIHN1cHBvcnQgYG51bGxgLlxuICAgICAgYWxpZ25EZWxpbWl0ZXJzLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYG1hcmtkb3duLXRhYmxlYCB0eXBlcyBzaG91bGQgc3VwcG9ydCBgbnVsbGAuXG4gICAgICBwYWRkaW5nLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYG1hcmtkb3duLXRhYmxlYCB0eXBlcyBzaG91bGQgc3VwcG9ydCBgbnVsbGAuXG4gICAgICBzdHJpbmdMZW5ndGhcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGFibGV9IG5vZGVcbiAgICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAgICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZUFzRGF0YShub2RlLCBzdGF0ZSwgaW5mbykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlblxuICAgIGxldCBpbmRleCA9IC0xXG4gICAgLyoqIEB0eXBlIHtBcnJheTxBcnJheTxzdHJpbmc+Pn0gKi9cbiAgICBjb25zdCByZXN1bHQgPSBbXVxuICAgIGNvbnN0IHN1YmV4aXQgPSBzdGF0ZS5lbnRlcigndGFibGUnKVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBoYW5kbGVUYWJsZVJvd0FzRGF0YShjaGlsZHJlbltpbmRleF0sIHN0YXRlLCBpbmZvKVxuICAgIH1cblxuICAgIHN1YmV4aXQoKVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGFibGVSb3d9IG5vZGVcbiAgICogQHBhcmFtIHtTdGF0ZX0gc3RhdGVcbiAgICogQHBhcmFtIHtJbmZvfSBpbmZvXG4gICAqL1xuICBmdW5jdGlvbiBoYW5kbGVUYWJsZVJvd0FzRGF0YShub2RlLCBzdGF0ZSwgaW5mbykge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5jaGlsZHJlblxuICAgIGxldCBpbmRleCA9IC0xXG4gICAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdXG4gICAgY29uc3Qgc3ViZXhpdCA9IHN0YXRlLmVudGVyKCd0YWJsZVJvdycpXG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gTm90ZTogdGhlIHBvc2l0aW9uYWwgaW5mbyBhcyB1c2VkIGhlcmUgaXMgaW5jb3JyZWN0LlxuICAgICAgLy8gTWFraW5nIGl0IGNvcnJlY3Qgd291bGQgYmUgaW1wb3NzaWJsZSBkdWUgdG8gYWxpZ25pbmcgY2VsbHM/XG4gICAgICAvLyBBbmQgaXQgd291bGQgbmVlZCBjb3B5L3Bhc3RpbmcgYG1hcmtkb3duLXRhYmxlYCBpbnRvIHRoaXMgcHJvamVjdC5cbiAgICAgIHJlc3VsdFtpbmRleF0gPSBoYW5kbGVUYWJsZUNlbGwoY2hpbGRyZW5baW5kZXhdLCBub2RlLCBzdGF0ZSwgaW5mbylcbiAgICB9XG5cbiAgICBzdWJleGl0KClcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7VG9NYXJrZG93bkhhbmRsZX1cbiAgICogQHBhcmFtIHtJbmxpbmVDb2RlfSBub2RlXG4gICAqL1xuICBmdW5jdGlvbiBpbmxpbmVDb2RlV2l0aFRhYmxlKG5vZGUsIHBhcmVudCwgc3RhdGUpIHtcbiAgICBsZXQgdmFsdWUgPSBkZWZhdWx0SGFuZGxlcnMuaW5saW5lQ29kZShub2RlLCBwYXJlbnQsIHN0YXRlKVxuXG4gICAgaWYgKHN0YXRlLnN0YWNrLmluY2x1ZGVzKCd0YWJsZUNlbGwnKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHwvZywgJ1xcXFwkJicpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJvayIsImFzc2VydCIsIm1hcmtkb3duVGFibGUiLCJkZWZhdWx0SGFuZGxlcnMiLCJnZm1UYWJsZUZyb21NYXJrZG93biIsImVudGVyIiwidGFibGUiLCJlbnRlclRhYmxlIiwidGFibGVEYXRhIiwiZW50ZXJDZWxsIiwidGFibGVIZWFkZXIiLCJ0YWJsZVJvdyIsImVudGVyUm93IiwiZXhpdCIsImNvZGVUZXh0IiwiZXhpdENvZGVUZXh0IiwiZXhpdFRhYmxlIiwidG9rZW4iLCJhbGlnbiIsIl9hbGlnbiIsInR5cGUiLCJtYXAiLCJkIiwiY2hpbGRyZW4iLCJkYXRhIiwiaW5UYWJsZSIsInVuZGVmaW5lZCIsInZhbHVlIiwicmVzdW1lIiwicmVwbGFjZSIsIm5vZGUiLCJzdGFjayIsImxlbmd0aCIsIiQwIiwiJDEiLCJnZm1UYWJsZVRvTWFya2Rvd24iLCJvcHRpb25zIiwic2V0dGluZ3MiLCJwYWRkaW5nIiwidGFibGVDZWxsUGFkZGluZyIsImFsaWduRGVsaW1pdGVycyIsInRhYmxlUGlwZUFsaWduIiwic3RyaW5nTGVuZ3RoIiwiYXJvdW5kIiwidW5zYWZlIiwiY2hhcmFjdGVyIiwiaW5Db25zdHJ1Y3QiLCJhdEJyZWFrIiwiYWZ0ZXIiLCJoYW5kbGVycyIsImlubGluZUNvZGUiLCJpbmxpbmVDb2RlV2l0aFRhYmxlIiwiaGFuZGxlVGFibGUiLCJ0YWJsZUNlbGwiLCJoYW5kbGVUYWJsZUNlbGwiLCJoYW5kbGVUYWJsZVJvdyIsIl8iLCJzdGF0ZSIsImluZm8iLCJzZXJpYWxpemVEYXRhIiwiaGFuZGxlVGFibGVBc0RhdGEiLCJyb3ciLCJoYW5kbGVUYWJsZVJvd0FzRGF0YSIsInNsaWNlIiwiaW5kZXhPZiIsInN1YmV4aXQiLCJjb250YWluZXJQaHJhc2luZyIsImJlZm9yZSIsIm1hdHJpeCIsImluZGV4IiwicmVzdWx0IiwicGFyZW50IiwiaW5jbHVkZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/mdast-util-gfm-table/lib/index.js\n");

/***/ })

};
;